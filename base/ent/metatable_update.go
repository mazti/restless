// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/mazti/restless/base/ent/metacolumn"
	"github.com/mazti/restless/base/ent/metaschema"
	"github.com/mazti/restless/base/ent/metatable"
	"github.com/mazti/restless/base/ent/predicate"
)

// MetaTableUpdate is the builder for updating MetaTable entities.
type MetaTableUpdate struct {
	config
	name            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	cleardeleted_at bool
	schema          map[int]struct{}
	columns         map[int]struct{}
	clearedSchema   bool
	removedColumns  map[int]struct{}
	predicates      []predicate.MetaTable
}

// Where adds a new predicate for the builder.
func (mtu *MetaTableUpdate) Where(ps ...predicate.MetaTable) *MetaTableUpdate {
	mtu.predicates = append(mtu.predicates, ps...)
	return mtu
}

// SetName sets the name field.
func (mtu *MetaTableUpdate) SetName(s string) *MetaTableUpdate {
	mtu.name = &s
	return mtu
}

// SetCreatedAt sets the created_at field.
func (mtu *MetaTableUpdate) SetCreatedAt(t time.Time) *MetaTableUpdate {
	mtu.created_at = &t
	return mtu
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (mtu *MetaTableUpdate) SetNillableCreatedAt(t *time.Time) *MetaTableUpdate {
	if t != nil {
		mtu.SetCreatedAt(*t)
	}
	return mtu
}

// SetUpdatedAt sets the updated_at field.
func (mtu *MetaTableUpdate) SetUpdatedAt(t time.Time) *MetaTableUpdate {
	mtu.updated_at = &t
	return mtu
}

// SetNillableUpdatedAt sets the updated_at field if the given value is not nil.
func (mtu *MetaTableUpdate) SetNillableUpdatedAt(t *time.Time) *MetaTableUpdate {
	if t != nil {
		mtu.SetUpdatedAt(*t)
	}
	return mtu
}

// SetDeletedAt sets the deleted_at field.
func (mtu *MetaTableUpdate) SetDeletedAt(t time.Time) *MetaTableUpdate {
	mtu.deleted_at = &t
	return mtu
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (mtu *MetaTableUpdate) SetNillableDeletedAt(t *time.Time) *MetaTableUpdate {
	if t != nil {
		mtu.SetDeletedAt(*t)
	}
	return mtu
}

// ClearDeletedAt clears the value of deleted_at.
func (mtu *MetaTableUpdate) ClearDeletedAt() *MetaTableUpdate {
	mtu.deleted_at = nil
	mtu.cleardeleted_at = true
	return mtu
}

// SetSchemaID sets the schema edge to MetaSchema by id.
func (mtu *MetaTableUpdate) SetSchemaID(id int) *MetaTableUpdate {
	if mtu.schema == nil {
		mtu.schema = make(map[int]struct{})
	}
	mtu.schema[id] = struct{}{}
	return mtu
}

// SetNillableSchemaID sets the schema edge to MetaSchema by id if the given value is not nil.
func (mtu *MetaTableUpdate) SetNillableSchemaID(id *int) *MetaTableUpdate {
	if id != nil {
		mtu = mtu.SetSchemaID(*id)
	}
	return mtu
}

// SetSchema sets the schema edge to MetaSchema.
func (mtu *MetaTableUpdate) SetSchema(m *MetaSchema) *MetaTableUpdate {
	return mtu.SetSchemaID(m.ID)
}

// AddColumnIDs adds the columns edge to MetaColumn by ids.
func (mtu *MetaTableUpdate) AddColumnIDs(ids ...int) *MetaTableUpdate {
	if mtu.columns == nil {
		mtu.columns = make(map[int]struct{})
	}
	for i := range ids {
		mtu.columns[ids[i]] = struct{}{}
	}
	return mtu
}

// AddColumns adds the columns edges to MetaColumn.
func (mtu *MetaTableUpdate) AddColumns(m ...*MetaColumn) *MetaTableUpdate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return mtu.AddColumnIDs(ids...)
}

// ClearSchema clears the schema edge to MetaSchema.
func (mtu *MetaTableUpdate) ClearSchema() *MetaTableUpdate {
	mtu.clearedSchema = true
	return mtu
}

// RemoveColumnIDs removes the columns edge to MetaColumn by ids.
func (mtu *MetaTableUpdate) RemoveColumnIDs(ids ...int) *MetaTableUpdate {
	if mtu.removedColumns == nil {
		mtu.removedColumns = make(map[int]struct{})
	}
	for i := range ids {
		mtu.removedColumns[ids[i]] = struct{}{}
	}
	return mtu
}

// RemoveColumns removes columns edges to MetaColumn.
func (mtu *MetaTableUpdate) RemoveColumns(m ...*MetaColumn) *MetaTableUpdate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return mtu.RemoveColumnIDs(ids...)
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (mtu *MetaTableUpdate) Save(ctx context.Context) (int, error) {
	if len(mtu.schema) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"schema\"")
	}
	return mtu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (mtu *MetaTableUpdate) SaveX(ctx context.Context) int {
	affected, err := mtu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (mtu *MetaTableUpdate) Exec(ctx context.Context) error {
	_, err := mtu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (mtu *MetaTableUpdate) ExecX(ctx context.Context) {
	if err := mtu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (mtu *MetaTableUpdate) sqlSave(ctx context.Context) (n int, err error) {
	spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   metatable.Table,
			Columns: metatable.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: metatable.FieldID,
			},
		},
	}
	if ps := mtu.predicates; len(ps) > 0 {
		spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := mtu.name; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: metatable.FieldName,
		})
	}
	if value := mtu.created_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metatable.FieldCreatedAt,
		})
	}
	if value := mtu.updated_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metatable.FieldUpdatedAt,
		})
	}
	if value := mtu.deleted_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metatable.FieldDeletedAt,
		})
	}
	if mtu.cleardeleted_at {
		spec.Fields.Clear = append(spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: metatable.FieldDeletedAt,
		})
	}
	if mtu.clearedSchema {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   metatable.SchemaTable,
			Columns: []string{metatable.SchemaColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metaschema.FieldID,
				},
			},
		}
		spec.Edges.Clear = append(spec.Edges.Clear, edge)
	}
	if nodes := mtu.schema; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   metatable.SchemaTable,
			Columns: []string{metatable.SchemaColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metaschema.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		spec.Edges.Add = append(spec.Edges.Add, edge)
	}
	if nodes := mtu.removedColumns; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   metatable.ColumnsTable,
			Columns: []string{metatable.ColumnsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metacolumn.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		spec.Edges.Clear = append(spec.Edges.Clear, edge)
	}
	if nodes := mtu.columns; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   metatable.ColumnsTable,
			Columns: []string{metatable.ColumnsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metacolumn.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		spec.Edges.Add = append(spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, mtu.driver, spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// MetaTableUpdateOne is the builder for updating a single MetaTable entity.
type MetaTableUpdateOne struct {
	config
	id              int
	name            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	cleardeleted_at bool
	schema          map[int]struct{}
	columns         map[int]struct{}
	clearedSchema   bool
	removedColumns  map[int]struct{}
}

// SetName sets the name field.
func (mtuo *MetaTableUpdateOne) SetName(s string) *MetaTableUpdateOne {
	mtuo.name = &s
	return mtuo
}

// SetCreatedAt sets the created_at field.
func (mtuo *MetaTableUpdateOne) SetCreatedAt(t time.Time) *MetaTableUpdateOne {
	mtuo.created_at = &t
	return mtuo
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (mtuo *MetaTableUpdateOne) SetNillableCreatedAt(t *time.Time) *MetaTableUpdateOne {
	if t != nil {
		mtuo.SetCreatedAt(*t)
	}
	return mtuo
}

// SetUpdatedAt sets the updated_at field.
func (mtuo *MetaTableUpdateOne) SetUpdatedAt(t time.Time) *MetaTableUpdateOne {
	mtuo.updated_at = &t
	return mtuo
}

// SetNillableUpdatedAt sets the updated_at field if the given value is not nil.
func (mtuo *MetaTableUpdateOne) SetNillableUpdatedAt(t *time.Time) *MetaTableUpdateOne {
	if t != nil {
		mtuo.SetUpdatedAt(*t)
	}
	return mtuo
}

// SetDeletedAt sets the deleted_at field.
func (mtuo *MetaTableUpdateOne) SetDeletedAt(t time.Time) *MetaTableUpdateOne {
	mtuo.deleted_at = &t
	return mtuo
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (mtuo *MetaTableUpdateOne) SetNillableDeletedAt(t *time.Time) *MetaTableUpdateOne {
	if t != nil {
		mtuo.SetDeletedAt(*t)
	}
	return mtuo
}

// ClearDeletedAt clears the value of deleted_at.
func (mtuo *MetaTableUpdateOne) ClearDeletedAt() *MetaTableUpdateOne {
	mtuo.deleted_at = nil
	mtuo.cleardeleted_at = true
	return mtuo
}

// SetSchemaID sets the schema edge to MetaSchema by id.
func (mtuo *MetaTableUpdateOne) SetSchemaID(id int) *MetaTableUpdateOne {
	if mtuo.schema == nil {
		mtuo.schema = make(map[int]struct{})
	}
	mtuo.schema[id] = struct{}{}
	return mtuo
}

// SetNillableSchemaID sets the schema edge to MetaSchema by id if the given value is not nil.
func (mtuo *MetaTableUpdateOne) SetNillableSchemaID(id *int) *MetaTableUpdateOne {
	if id != nil {
		mtuo = mtuo.SetSchemaID(*id)
	}
	return mtuo
}

// SetSchema sets the schema edge to MetaSchema.
func (mtuo *MetaTableUpdateOne) SetSchema(m *MetaSchema) *MetaTableUpdateOne {
	return mtuo.SetSchemaID(m.ID)
}

// AddColumnIDs adds the columns edge to MetaColumn by ids.
func (mtuo *MetaTableUpdateOne) AddColumnIDs(ids ...int) *MetaTableUpdateOne {
	if mtuo.columns == nil {
		mtuo.columns = make(map[int]struct{})
	}
	for i := range ids {
		mtuo.columns[ids[i]] = struct{}{}
	}
	return mtuo
}

// AddColumns adds the columns edges to MetaColumn.
func (mtuo *MetaTableUpdateOne) AddColumns(m ...*MetaColumn) *MetaTableUpdateOne {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return mtuo.AddColumnIDs(ids...)
}

// ClearSchema clears the schema edge to MetaSchema.
func (mtuo *MetaTableUpdateOne) ClearSchema() *MetaTableUpdateOne {
	mtuo.clearedSchema = true
	return mtuo
}

// RemoveColumnIDs removes the columns edge to MetaColumn by ids.
func (mtuo *MetaTableUpdateOne) RemoveColumnIDs(ids ...int) *MetaTableUpdateOne {
	if mtuo.removedColumns == nil {
		mtuo.removedColumns = make(map[int]struct{})
	}
	for i := range ids {
		mtuo.removedColumns[ids[i]] = struct{}{}
	}
	return mtuo
}

// RemoveColumns removes columns edges to MetaColumn.
func (mtuo *MetaTableUpdateOne) RemoveColumns(m ...*MetaColumn) *MetaTableUpdateOne {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return mtuo.RemoveColumnIDs(ids...)
}

// Save executes the query and returns the updated entity.
func (mtuo *MetaTableUpdateOne) Save(ctx context.Context) (*MetaTable, error) {
	if len(mtuo.schema) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"schema\"")
	}
	return mtuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (mtuo *MetaTableUpdateOne) SaveX(ctx context.Context) *MetaTable {
	mt, err := mtuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return mt
}

// Exec executes the query on the entity.
func (mtuo *MetaTableUpdateOne) Exec(ctx context.Context) error {
	_, err := mtuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (mtuo *MetaTableUpdateOne) ExecX(ctx context.Context) {
	if err := mtuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (mtuo *MetaTableUpdateOne) sqlSave(ctx context.Context) (mt *MetaTable, err error) {
	spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   metatable.Table,
			Columns: metatable.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  mtuo.id,
				Type:   field.TypeInt,
				Column: metatable.FieldID,
			},
		},
	}
	if value := mtuo.name; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: metatable.FieldName,
		})
	}
	if value := mtuo.created_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metatable.FieldCreatedAt,
		})
	}
	if value := mtuo.updated_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metatable.FieldUpdatedAt,
		})
	}
	if value := mtuo.deleted_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metatable.FieldDeletedAt,
		})
	}
	if mtuo.cleardeleted_at {
		spec.Fields.Clear = append(spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: metatable.FieldDeletedAt,
		})
	}
	if mtuo.clearedSchema {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   metatable.SchemaTable,
			Columns: []string{metatable.SchemaColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metaschema.FieldID,
				},
			},
		}
		spec.Edges.Clear = append(spec.Edges.Clear, edge)
	}
	if nodes := mtuo.schema; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   metatable.SchemaTable,
			Columns: []string{metatable.SchemaColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metaschema.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		spec.Edges.Add = append(spec.Edges.Add, edge)
	}
	if nodes := mtuo.removedColumns; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   metatable.ColumnsTable,
			Columns: []string{metatable.ColumnsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metacolumn.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		spec.Edges.Clear = append(spec.Edges.Clear, edge)
	}
	if nodes := mtuo.columns; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   metatable.ColumnsTable,
			Columns: []string{metatable.ColumnsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: metacolumn.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		spec.Edges.Add = append(spec.Edges.Add, edge)
	}
	mt = &MetaTable{config: mtuo.config}
	spec.Assign = mt.assignValues
	spec.ScanValues = mt.scanValues()
	if err = sqlgraph.UpdateNode(ctx, mtuo.driver, spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return mt, nil
}
