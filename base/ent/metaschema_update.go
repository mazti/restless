// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/mazti/restless/base/ent/metaschema"
	"github.com/mazti/restless/base/ent/predicate"
)

// MetaSchemaUpdate is the builder for updating MetaSchema entities.
type MetaSchemaUpdate struct {
	config
	base            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	cleardeleted_at bool
	predicates      []predicate.MetaSchema
}

// Where adds a new predicate for the builder.
func (msu *MetaSchemaUpdate) Where(ps ...predicate.MetaSchema) *MetaSchemaUpdate {
	msu.predicates = append(msu.predicates, ps...)
	return msu
}

// SetBase sets the base field.
func (msu *MetaSchemaUpdate) SetBase(s string) *MetaSchemaUpdate {
	msu.base = &s
	return msu
}

// SetCreatedAt sets the created_at field.
func (msu *MetaSchemaUpdate) SetCreatedAt(t time.Time) *MetaSchemaUpdate {
	msu.created_at = &t
	return msu
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (msu *MetaSchemaUpdate) SetNillableCreatedAt(t *time.Time) *MetaSchemaUpdate {
	if t != nil {
		msu.SetCreatedAt(*t)
	}
	return msu
}

// SetUpdatedAt sets the updated_at field.
func (msu *MetaSchemaUpdate) SetUpdatedAt(t time.Time) *MetaSchemaUpdate {
	msu.updated_at = &t
	return msu
}

// SetNillableUpdatedAt sets the updated_at field if the given value is not nil.
func (msu *MetaSchemaUpdate) SetNillableUpdatedAt(t *time.Time) *MetaSchemaUpdate {
	if t != nil {
		msu.SetUpdatedAt(*t)
	}
	return msu
}

// SetDeletedAt sets the deleted_at field.
func (msu *MetaSchemaUpdate) SetDeletedAt(t time.Time) *MetaSchemaUpdate {
	msu.deleted_at = &t
	return msu
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (msu *MetaSchemaUpdate) SetNillableDeletedAt(t *time.Time) *MetaSchemaUpdate {
	if t != nil {
		msu.SetDeletedAt(*t)
	}
	return msu
}

// ClearDeletedAt clears the value of deleted_at.
func (msu *MetaSchemaUpdate) ClearDeletedAt() *MetaSchemaUpdate {
	msu.deleted_at = nil
	msu.cleardeleted_at = true
	return msu
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (msu *MetaSchemaUpdate) Save(ctx context.Context) (int, error) {
	return msu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (msu *MetaSchemaUpdate) SaveX(ctx context.Context) int {
	affected, err := msu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (msu *MetaSchemaUpdate) Exec(ctx context.Context) error {
	_, err := msu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (msu *MetaSchemaUpdate) ExecX(ctx context.Context) {
	if err := msu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (msu *MetaSchemaUpdate) sqlSave(ctx context.Context) (n int, err error) {
	spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   metaschema.Table,
			Columns: metaschema.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: metaschema.FieldID,
			},
		},
	}
	if ps := msu.predicates; len(ps) > 0 {
		spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := msu.base; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: metaschema.FieldBase,
		})
	}
	if value := msu.created_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metaschema.FieldCreatedAt,
		})
	}
	if value := msu.updated_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metaschema.FieldUpdatedAt,
		})
	}
	if value := msu.deleted_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metaschema.FieldDeletedAt,
		})
	}
	if msu.cleardeleted_at {
		spec.Fields.Clear = append(spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: metaschema.FieldDeletedAt,
		})
	}
	if n, err = sqlgraph.UpdateNodes(ctx, msu.driver, spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// MetaSchemaUpdateOne is the builder for updating a single MetaSchema entity.
type MetaSchemaUpdateOne struct {
	config
	id              int
	base            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	cleardeleted_at bool
}

// SetBase sets the base field.
func (msuo *MetaSchemaUpdateOne) SetBase(s string) *MetaSchemaUpdateOne {
	msuo.base = &s
	return msuo
}

// SetCreatedAt sets the created_at field.
func (msuo *MetaSchemaUpdateOne) SetCreatedAt(t time.Time) *MetaSchemaUpdateOne {
	msuo.created_at = &t
	return msuo
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (msuo *MetaSchemaUpdateOne) SetNillableCreatedAt(t *time.Time) *MetaSchemaUpdateOne {
	if t != nil {
		msuo.SetCreatedAt(*t)
	}
	return msuo
}

// SetUpdatedAt sets the updated_at field.
func (msuo *MetaSchemaUpdateOne) SetUpdatedAt(t time.Time) *MetaSchemaUpdateOne {
	msuo.updated_at = &t
	return msuo
}

// SetNillableUpdatedAt sets the updated_at field if the given value is not nil.
func (msuo *MetaSchemaUpdateOne) SetNillableUpdatedAt(t *time.Time) *MetaSchemaUpdateOne {
	if t != nil {
		msuo.SetUpdatedAt(*t)
	}
	return msuo
}

// SetDeletedAt sets the deleted_at field.
func (msuo *MetaSchemaUpdateOne) SetDeletedAt(t time.Time) *MetaSchemaUpdateOne {
	msuo.deleted_at = &t
	return msuo
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (msuo *MetaSchemaUpdateOne) SetNillableDeletedAt(t *time.Time) *MetaSchemaUpdateOne {
	if t != nil {
		msuo.SetDeletedAt(*t)
	}
	return msuo
}

// ClearDeletedAt clears the value of deleted_at.
func (msuo *MetaSchemaUpdateOne) ClearDeletedAt() *MetaSchemaUpdateOne {
	msuo.deleted_at = nil
	msuo.cleardeleted_at = true
	return msuo
}

// Save executes the query and returns the updated entity.
func (msuo *MetaSchemaUpdateOne) Save(ctx context.Context) (*MetaSchema, error) {
	return msuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (msuo *MetaSchemaUpdateOne) SaveX(ctx context.Context) *MetaSchema {
	ms, err := msuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return ms
}

// Exec executes the query on the entity.
func (msuo *MetaSchemaUpdateOne) Exec(ctx context.Context) error {
	_, err := msuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (msuo *MetaSchemaUpdateOne) ExecX(ctx context.Context) {
	if err := msuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (msuo *MetaSchemaUpdateOne) sqlSave(ctx context.Context) (ms *MetaSchema, err error) {
	spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   metaschema.Table,
			Columns: metaschema.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  msuo.id,
				Type:   field.TypeInt,
				Column: metaschema.FieldID,
			},
		},
	}
	if value := msuo.base; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: metaschema.FieldBase,
		})
	}
	if value := msuo.created_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metaschema.FieldCreatedAt,
		})
	}
	if value := msuo.updated_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metaschema.FieldUpdatedAt,
		})
	}
	if value := msuo.deleted_at; value != nil {
		spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: metaschema.FieldDeletedAt,
		})
	}
	if msuo.cleardeleted_at {
		spec.Fields.Clear = append(spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: metaschema.FieldDeletedAt,
		})
	}
	ms = &MetaSchema{config: msuo.config}
	spec.Assign = ms.assignValues
	spec.ScanValues = ms.scanValues()
	if err = sqlgraph.UpdateNode(ctx, msuo.driver, spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return ms, nil
}
